<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Beatbox Looper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .recorder-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .recorder-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .record-btn {
            background: #ff4d4d;
            color: white;
        }
        
        .record-btn:hover {
            background: #ff3333;
            transform: scale(1.05);
        }
        
        .record-btn.recording {
            background: #ff0000;
            animation: pulse 1.5s infinite;
        }
        
        .stop-btn {
            background: #4CAF50;
            color: white;
        }
        
        .stop-btn:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        
        .loop-btn {
            background: #9C27B0;
            color: white;
        }
        
        .loop-btn:hover {
            background: #8E24AA;
            transform: scale(1.05);
        }
        
        .loop-btn.looping {
            background: #7B1FA2;
        }
        
        .download-btn {
            background: #2196F3;
            color: white;
        }
        
        .download-btn:hover {
            background: #0b7dda;
            transform: scale(1.05);
        }
        
        .timer-display {
            text-align: center;
            font-size: 1.5rem;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .progress-container {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #ff4d4d, #ffcc00);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .visualizer {
            height: 120px;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
            position: relative;
        }
        
        .visualizer-bars {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 100%;
            padding: 0 10px;
        }
        
        .bar {
            width: 8px;
            background: linear-gradient(to top, #ff4d4d, #ffcc00);
            border-radius: 4px 4px 0 0;
            transition: height 0.1s ease;
        }
        
        .tracks-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .tracks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .tracks-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .track {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 15px;
            border-radius: 10px;
        }
        
        .track-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .track-name {
            flex: 1;
        }
        
        .track-controls {
            display: flex;
            gap: 10px;
        }
        
        .track-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
            transition: transform 0.2s;
        }
        
        .track-btn:hover {
            transform: scale(1.2);
        }
        
        .volume-slider {
            width: 100px;
        }
        
        .mixer-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .mixer-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .bpm-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .bpm-slider {
            width: 150px;
        }
        
        .playback-controls {
            display: flex;
            gap: 15px;
        }
        
        .play-btn {
            background: #9C27B0;
            color: white;
        }
        
        .play-btn:hover {
            background: #8E24AA;
            transform: scale(1.05);
        }
        
        .play-btn.playing {
            background: #7B1FA2;
        }
        
        .clear-btn {
            background: #FF9800;
            color: white;
        }
        
        .clear-btn:hover {
            background: #F57C00;
            transform: scale(1.05);
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }
        
        .instructions {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .instructions h3 {
            margin-bottom: 10px;
        }
        
        .instructions ol {
            padding-left: 20px;
            line-height: 1.6;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            opacity: 0.8;
            font-size: 0.9rem;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .recorder-controls, .mixer-controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .bpm-control, .playback-controls {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Voice Beatbox Looper</h1>
            <p class="subtitle">Record your voice, create loops, layer tracks, and download your mix!</p>
        </header>
        
        <div class="main-content">
            <section class="recorder-section">
                <h2>Voice Recorder</h2>
                <div class="timer-display" id="timerDisplay">00:00 / 05:00</div>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="recorder-controls">
                    <button id="recordBtn" class="btn record-btn">
                        <span>‚óè</span> Start Recording
                    </button>
                    <button id="loopBtn" class="btn loop-btn">
                        <span>‚ü≥</span> Start Loop
                    </button>
                    <button id="stopBtn" class="btn stop-btn" disabled>
                        <span>‚ñ†</span> Stop Recording
                    </button>
                    <button id="downloadBtn" class="btn download-btn">
                        <span>‚Üì</span> Download MP3
                    </button>
                </div>
                <div class="visualizer">
                    <div class="visualizer-bars" id="visualizer">
                        <!-- Visualizer bars will be generated by JavaScript -->
                    </div>
                </div>
            </section>
            
            <section class="tracks-section">
                <div class="tracks-header">
                    <h2>Recorded Tracks</h2>
                    <span id="trackCount">0 tracks</span>
                </div>
                <div class="tracks-container" id="tracksContainer">
                    <!-- Track elements will be added here -->
                </div>
            </section>
            
            <section class="mixer-section">
                <h2>Mixer Controls</h2>
                <div class="mixer-controls">
                    <div class="bpm-control">
                        <label for="bpmSlider">BPM: <span id="bpmValue">120</span></label>
                        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="120">
                    </div>
                    <div class="playback-controls">
                        <button id="playBtn" class="btn play-btn">
                            <span>‚ñ∂</span> Play All
                        </button>
                        <button id="clearBtn" class="btn clear-btn">
                            <span>√ó</span> Clear All
                        </button>
                    </div>
                </div>
            </section>
            
            <section class="instructions">
                <h3>How to Use</h3>
                <ol>
                    <li>Click "Start Recording" to record your voice beatboxing (max 5 minutes)</li>
                    <li>Click "Start Loop" to record and automatically loop your beat</li>
                    <li>Click "Stop Recording" when finished - your track will appear below</li>
                    <li>Repeat to add multiple layers of beats</li>
                    <li>Adjust volume and BPM (beats per minute) to your preference</li>
                    <li>Click "Play All" to hear your layered beatbox loop</li>
                    <li>Use "Download MP3" to save your creation</li>
                </ol>
            </section>
        </div>
        
        <footer>
            <p>Voice Beatbox Looper &copy; 2023 | Create amazing beats with just your voice!</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const recordBtn = document.getElementById('recordBtn');
            const loopBtn = document.getElementById('loopBtn');
            const stopBtn = document.getElementById('stopBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const playBtn = document.getElementById('playBtn');
            const clearBtn = document.getElementById('clearBtn');
            const bpmSlider = document.getElementById('bpmSlider');
            const bpmValue = document.getElementById('bpmValue');
            const visualizer = document.getElementById('visualizer');
            const tracksContainer = document.getElementById('tracksContainer');
            const trackCount = document.getElementById('trackCount');
            const timerDisplay = document.getElementById('timerDisplay');
            const progressBar = document.getElementById('progressBar');
            
            // Audio context and variables
            let audioContext;
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            let isLooping = false;
            let tracks = [];
            let isPlaying = false;
            let audioSources = [];
            let analyser;
            let animationId;
            let recordingTimer;
            let recordingStartTime;
            const MAX_RECORDING_TIME = 5 * 60 * 1000; // 5 minutes in milliseconds
            
            // Colors for tracks
            const trackColors = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', 
                '#536DFE', '#448AFF', '#40C4FF', '#18FFFF',
                '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41'
            ];
            
            // Create visualizer bars
            for (let i = 0; i < 32; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = '5px';
                visualizer.appendChild(bar);
            }
            
            // Initialize audio context
            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 64;
                }
            }
            
            // Update BPM display
            bpmSlider.addEventListener('input', function() {
                bpmValue.textContent = this.value;
            });
            
            // Format time for display
            function formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update recording timer
            function updateRecordingTimer() {
                if (!isRecording) return;
                
                const currentTime = Date.now();
                const elapsedTime = currentTime - recordingStartTime;
                const remainingTime = Math.max(0, MAX_RECORDING_TIME - elapsedTime);
                
                // Update timer display
                timerDisplay.textContent = `${formatTime(elapsedTime)} / ${formatTime(MAX_RECORDING_TIME)}`;
                
                // Update progress bar
                const progressPercent = (elapsedTime / MAX_RECORDING_TIME) * 100;
                progressBar.style.width = `${progressPercent}%`;
                
                // Change progress bar color when approaching limit
                if (progressPercent > 90) {
                    progressBar.style.background = 'linear-gradient(to right, #ff4d4d, #ff0000)';
                } else if (progressPercent > 75) {
                    progressBar.style.background = 'linear-gradient(to right, #ffcc00, #ff4d4d)';
                }
                
                // Stop recording if time limit reached
                if (elapsedTime >= MAX_RECORDING_TIME) {
                    stopRecording();
                    alert("Maximum recording time of 5 minutes reached!");
                }
            }
            
            // Start recording
            recordBtn.addEventListener('click', async function() {
                await startRecording(false);
            });
            
            // Start loop recording
            loopBtn.addEventListener('click', async function() {
                await startRecording(true);
            });
            
            // Common function to start recording
            async function startRecording(loopMode) {
                try {
                    initAudioContext();
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    
                    mediaRecorder.ondataavailable = function(event) {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = function() {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        addTrack(audioBlob, loopMode);
                        audioChunks = [];
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    isLooping = loopMode;
                    
                    if (loopMode) {
                        loopBtn.classList.add('looping');
                    } else {
                        recordBtn.classList.add('recording');
                    }
                    
                    stopBtn.disabled = false;
                    recordBtn.disabled = true;
                    loopBtn.disabled = true;
                    
                    // Start recording timer
                    recordingStartTime = Date.now();
                    recordingTimer = setInterval(updateRecordingTimer, 100);
                    
                    // Start visualizer
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    updateVisualizer();
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    alert('Could not access your microphone. Please check permissions.');
                }
            }
            
            // Stop recording
            stopBtn.addEventListener('click', function() {
                stopRecording();
            });
            
            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    mediaRecorder.stop();
                    isRecording = false;
                    
                    // Clear recording timer
                    clearInterval(recordingTimer);
                    
                    // Reset UI
                    recordBtn.classList.remove('recording');
                    loopBtn.classList.remove('looping');
                    stopBtn.disabled = true;
                    recordBtn.disabled = false;
                    loopBtn.disabled = false;
                    
                    // Reset timer display
                    timerDisplay.textContent = '00:00 / 05:00';
                    progressBar.style.width = '0%';
                    progressBar.style.background = 'linear-gradient(to right, #ff4d4d, #ffcc00)';
                    
                    // Stop visualizer
                    cancelAnimationFrame(animationId);
                    resetVisualizer();
                }
            }
            
            // Add a new track
            function addTrack(audioBlob, isLoop) {
                const trackId = 'track-' + Date.now();
                const trackColor = trackColors[tracks.length % trackColors.length];
                
                // Create track element
                const trackElement = document.createElement('div');
                trackElement.className = 'track';
                trackElement.id = trackId;
                trackElement.innerHTML = `
                    <div class="track-color" style="background-color: ${trackColor};"></div>
                    <div class="track-name">${isLoop ? 'Loop ' : 'Track '}${tracks.length + 1}</div>
                    <input type="range" class="volume-slider" min="0" max="100" value="100">
                    <div class="track-controls">
                        <button class="track-btn play-track" title="Play">‚ñ∂</button>
                        <button class="track-btn loop-track" title="${isLoop ? 'Looping' : 'Loop'}">${isLoop ? '‚ü≥' : '‚Üª'}</button>
                        <button class="track-btn mute-track" title="Mute">üîá</button>
                        <button class="track-btn delete-track" title="Delete">√ó</button>
                    </div>
                `;
                
                tracksContainer.appendChild(trackElement);
                
                // Store track data
                const track = {
                    id: trackId,
                    blob: audioBlob,
                    element: trackElement,
                    volume: 1.0,
                    isMuted: false,
                    isLoop: isLoop,
                    buffer: null
                };
                
                tracks.push(track);
                updateTrackCount();
                
                // Load audio buffer
                loadAudioBuffer(track);
                
                // Add event listeners for track controls
                const volumeSlider = trackElement.querySelector('.volume-slider');
                const playBtn = trackElement.querySelector('.play-track');
                const loopBtn = trackElement.querySelector('.loop-track');
                const muteBtn = trackElement.querySelector('.mute-track');
                const deleteBtn = trackElement.querySelector('.delete-track');
                
                volumeSlider.addEventListener('input', function() {
                    track.volume = this.value / 100;
                });
                
                playBtn.addEventListener('click', function() {
                    playTrack(track);
                });
                
                loopBtn.addEventListener('click', function() {
                    track.isLoop = !track.isLoop;
                    loopBtn.textContent = track.isLoop ? '‚ü≥' : '‚Üª';
                    loopBtn.title = track.isLoop ? 'Looping' : 'Loop';
                });
                
                muteBtn.addEventListener('click', function() {
                    track.isMuted = !track.isMuted;
                    muteBtn.textContent = track.isMuted ? 'üîà' : 'üîá';
                });
                
                deleteBtn.addEventListener('click', function() {
                    deleteTrack(trackId);
                });
            }
            
            // Load audio buffer for a track
            function loadAudioBuffer(track) {
                const fileReader = new FileReader();
                
                fileReader.onload = function() {
                    audioContext.decodeAudioData(this.result, function(buffer) {
                        track.buffer = buffer;
                    });
                };
                
                fileReader.readAsArrayBuffer(track.blob);
            }
            
            // Play a single track
            function playTrack(track) {
                if (!track.buffer) return;
                
                initAudioContext();
                
                const source = audioContext.createBufferSource();
                source.buffer = track.buffer;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = track.isMuted ? 0 : track.volume;
                
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                source.start();
                
                // If it's a loop track, set it to loop
                if (track.isLoop) {
                    source.loop = true;
                }
                
                // Store source for stopping if needed
                audioSources.push(source);
                
                source.onended = function() {
                    const index = audioSources.indexOf(source);
                    if (index > -1) {
                        audioSources.splice(index, 1);
                    }
                };
            }
            
            // Play all tracks
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    // Stop playback
                    stopPlayback();
                    playBtn.textContent = '‚ñ∂ Play All';
                    playBtn.classList.remove('playing');
                    isPlaying = false;
                } else {
                    // Start playback
                    if (tracks.length === 0) {
                        alert('No tracks to play. Record something first!');
                        return;
                    }
                    
                    initAudioContext();
                    playAllTracks();
                    playBtn.textContent = '‚èπ Stop';
                    playBtn.classList.add('playing');
                    isPlaying = true;
                }
            });
            
            // Play all tracks in a loop
            function playAllTracks() {
                const bpm = parseInt(bpmSlider.value);
                const interval = 60 / bpm * 4; // 4 beats per measure
                
                function scheduleTracks() {
                    tracks.forEach(track => {
                        if (track.buffer && !track.isMuted) {
                            const source = audioContext.createBufferSource();
                            source.buffer = track.buffer;
                            
                            // Set looping for loop tracks
                            if (track.isLoop) {
                                source.loop = true;
                            }
                            
                            const gainNode = audioContext.createGain();
                            gainNode.gain.value = track.volume;
                            
                            source.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            source.start();
                            audioSources.push(source);
                            
                            source.onended = function() {
                                const index = audioSources.indexOf(source);
                                if (index > -1) {
                                    audioSources.splice(index, 1);
                                }
                            };
                        }
                    });
                    
                    if (isPlaying) {
                        setTimeout(scheduleTracks, interval * 1000);
                    }
                }
                
                scheduleTracks();
            }
            
            // Stop all audio playback
            function stopPlayback() {
                audioSources.forEach(source => {
                    try {
                        source.stop();
                    } catch (e) {
                        // Source might have already ended
                    }
                });
                audioSources = [];
            }
            
            // Delete a track
            function deleteTrack(trackId) {
                const trackIndex = tracks.findIndex(track => track.id === trackId);
                
                if (trackIndex !== -1) {
                    tracks.splice(trackIndex, 1);
                    document.getElementById(trackId).remove();
                    updateTrackCount();
                }
            }
            
            // Clear all tracks
            clearBtn.addEventListener('click', function() {
                if (tracks.length === 0) return;
                
                if (confirm('Are you sure you want to clear all tracks?')) {
                    tracks = [];
                    tracksContainer.innerHTML = '';
                    updateTrackCount();
                    stopPlayback();
                    
                    if (isPlaying) {
                        playBtn.textContent = '‚ñ∂ Play All';
                        playBtn.classList.remove('playing');
                        isPlaying = false;
                    }
                }
            });
            
            // Update track count display
            function updateTrackCount() {
                trackCount.textContent = `${tracks.length} track${tracks.length !== 1 ? 's' : ''}`;
            }
            
            // Download mix as MP3 (simulated)
            downloadBtn.addEventListener('click', function() {
                if (tracks.length === 0) {
                    alert('No tracks to download. Record something first!');
                    return;
                }
                
                // In a real implementation, you would mix the tracks and encode to MP3
                // For this demo, we'll create a simulated download
                
                const simulatedBlob = new Blob(['Simulated MP3 content'], { type: 'audio/mp3' });
                const url = URL.createObjectURL(simulatedBlob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `beatbox-mix-${new Date().getTime()}.mp3`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('In a real implementation, this would download your actual mixed beatbox track as an MP3 file.');
            });
            
            // Visualizer functions
            function updateVisualizer() {
                if (!analyser) return;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);
                
                const bars = visualizer.querySelectorAll('.bar');
                
                for (let i = 0; i < bars.length; i++) {
                    const value = dataArray[i % bufferLength] / 255;
                    const height = Math.max(5, value * 100);
                    bars[i].style.height = `${height}px`;
                }
                
                animationId = requestAnimationFrame(updateVisualizer);
            }
            
            function resetVisualizer() {
                const bars = visualizer.querySelectorAll('.bar');
                bars.forEach(bar => {
                    bar.style.height = '5px';
                });
            }
        });
    </script>
</body>
</html>